#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{color}
\end_preamble
\use_default_options true
\language french
\inputencoding auto
\font_roman charter
\font_sans default
\font_typewriter cmtt
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Réponses aux questions
\end_layout

\begin_layout Author
J.
 Odersky 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 C.
 Vázquez
\end_layout

\begin_layout Section*
Question P1.1
\end_layout

\begin_layout Standard
Un vecteur est représenté par la classe `Vector3D'.
 Cette classe comprend trois champs privés du type double: x, y et z corresponda
nt aux composantes du vecteur.
 Ces champs peuvent être accédés respectivement par les méthodes publiques
 getX(), getY() et getZ().
 Les méthodes 
\begin_inset Quotes eld
\end_inset

opérateurs
\begin_inset Quotes erd
\end_inset

 sur les vecteurs (par exemple l'addition, la norme, etc...) sont toutes publiques.
\end_layout

\begin_layout Standard
Ces méthodes s'appuient entre-elles, par exemple la méthode `opposée' retourne
 le vecteur multiplié par moins un et la méthode `soustraction' additionne
 l'opposé.
 Ces appels consécutifs diminuent la performance d'une façon minimale mais
 évitent un duplicage de code considérable.
\end_layout

\begin_layout Standard
Un vecteur est complètement invariable.
 C'est-à-dire qu'une fois un vecteur initialisé, on ne peut plus changer
 ses composantes (pas de méthodes `set').
 De même, tous les opérations internes du sens mathématique (qui renvoyent
 un vecteur), renvoyent une nouvelle instance d'un vecteur.
 En aucun cas l'instance d'un vecteur n'est modifiée! Ceci facilite énormément
 le raisonement sur toute variable de type vecteur.
 De plus, l'invariance d'un vecteur paraît naturelle, comme celle d'un nombre
 réel.
\end_layout

\begin_layout Standard
Quelques vecteurs remarquables sont définis comme variables statiques constantes.
 Parmi ceux-ci notamment le vecteur nulle (Null) et les vecteurs unitaires
 i, j, k selon respectivement les axes x, y et z.
\end_layout

\begin_layout Section*
Question P3.1
\end_layout

\begin_layout Standard
Nous n'avons pas rajouté un constructeur de copie.
 Comme la classe `Vector3D' est invariable et ne contient pas de pointeurs
 ou références sur d'autres objets mutables, elle n'a pas d'état et donc
 l'utilisation du constructeur de copie par défaut suffit.
\end_layout

\begin_layout Section*
Question P3.2
\end_layout

\begin_layout Standard
Lorsque l'on décide d'implémenter le constructeur par défaut (qui crée un
 vecteur nul) et le constructeur par coordonnés cartésiennes dans une seule
 et même méthode, il se peut que lorsque l'on crée une nouvelle instance
 de Vector3D sans l'initialiser (en laissant donc le soin au constructeur
 par défaut de le faire), on se retrouve avec un vecteur nul à un endroit
 où il vaudrait mieux ne pas en avoir.
 Par conséquent, en séparant ces deux méthodes, le programmeur est amené
 à penser dès l'instanciation à quelle fin il crée son objet.
\end_layout

\begin_layout Section*
Question P3.3
\end_layout

\begin_layout Subsection*
a
\end_layout

\begin_layout Standard
En ajoutant un constructeur par coordonnées sphériques, les attributs de
 la classe ne devraient pas forcémant être changées.
 Il serait toute à fait envisageable, de garder les coordonnées carthésiennes
 comme attributs et de convertir les coordonnées sphériques avec le constructeur.
\end_layout

\begin_layout Subsection*
b
\end_layout

\begin_layout Standard
La surcharge serait une difficulté majeur pour créer un constructeur par
 coordonnées sphériques.
 Etant donné qu'un tel constructeur prendrait comme paramètres deux angles
 et une longueur, représentés par trois doubles, il serait en conflit avec
 le constructeur de coordonnées carthésiennes.
 Il serait alors impossible d'avoir les deux constructeurs dans une classe.
\end_layout

\begin_layout Standard
Néanmoins, une solution alternative serait d'implémenter une méthode statique
 (
\begin_inset Quotes eld
\end_inset

factory method
\begin_inset Quotes erd
\end_inset

) qui prendrait comme paramètres des coordonnées sphériques et qui renverait
 un vecteur ayant des coordonnées carthésiennes équivalentes (par exemple
 
\family typewriter
Vector3D Vector3D::fromSpherical(double phi, double theta, double r)
\family default
).
\end_layout

\begin_layout Section*
Question P3.4
\end_layout

\begin_layout Standard
La méthode `affiche()' d'un vecteur a été implémenté sous forme de l'opérateur
 `<<' de `std::ostream'.
 La méthode `compare' est équivalent à l'opérateur `=='.
\end_layout

\begin_layout Section*
Question P5.1
\end_layout

\begin_layout Standard

\emph on
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{red}{Réponse incohérente! La question conçernant l'énergie me perturbe...}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Les membres d'une particule représentant le facteur gamma
\begin_inset Formula $\gamma$
\end_inset

 et l'énergie
\begin_inset Formula $E$
\end_inset

 peuvent être implémentés soit sous forme d'attributs soit sous forme de
 méthodes.
 Il y a des avantages et inconvénients pour chaque forme.
\end_layout

\begin_layout Standard
L'avantage d'un attribut est que son accès est très rapide et ne prend (presque)
 pas de temps de calcul.
 Par contre, si la valeur d'un attribut est relié logiquement à la valeur
 d'un autre attribut et que ce dernier est modifié, il faudra manuellement
 changer le premier.
 Par exemple, le facteur gamma étant défini par:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\gamma=\frac{1}{\sqrt{1-\left(\frac{v}{c}\right)^{2}}}\]

\end_inset


\end_layout

\begin_layout Standard
si il est défini comme variable, il faudrait le mettre à jour à chaque fois
 que la vitesse change.
\end_layout

\begin_layout Standard
Contrairement à un attribut, une méthode est évaluée à chaque fois qu'on
 l'appelle.
 Ceci a l'avantage que si le résultat d'une méthode dépend d'une variable,
 la variable pourra être modifiée sans considération de la méthode.
 Ainsi, si le facteur gamma est une méthode, une mise à jour de la vitesse
 pourra être effectuée directement sans explicitement changer 
\begin_inset Formula $\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
Dans le cas de notre projet, nous avons décidés d'implémenter l'énergie
 sous forme d'attribut et le facteur gamma sous forme de méthode.
 Ceci pour plusieurs raisons:
\end_layout

\begin_layout Enumerate
Au cours de la simulation, la vitesse sera changée très fréquemment, beaucoup
 plus que les appels à gamma.
 Une implémentation de gamma sous forme de méthode améliore donc la performance.
\end_layout

\begin_layout Enumerate
Le premier argument pourrait s'appliquer également à l'énergie, or il faut
 remarquer que l'énergie est une grandeur spécifiée durant la création d'une
 particule et que en fait la vitesse dépend de l'énergie
\begin_inset Foot
status open

\begin_layout Plain Layout
Complément mathématique: 
\begin_inset Quotes eld
\end_inset

Aux énergies atteintes dans un accélérateur, les particules sont tellement
 proches de la vitesse de la lumière qu'il faudrait garder au moins 7 décimales
 pour que la vitesse permette de connaître l'énergie de façon assez précise.
 On caractérise donc plutôt une particule en termes d'énergie totale que
 de vitesse.
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 On pourrait alors penser à définir la vitesse comme méthode mais d'après
 l'argument 1, ce serait complètement absurde au niveau de la performance.
\end_layout

\begin_layout Section*
Question P6.1
\end_layout

\begin_layout Standard
Pour représenter et oraniser les éléments, nous avons choisi dans ce projet
 de coder les éléments (magnétiques et électriques, droits et courbes) sous
 formes de classes.
 Concrètement, la classe 
\family typewriter
\size small
Element
\family default
\size default
 est la classe grand-mère, les quatre classes filles sont les classes
\family typewriter
\size small
 Droit 
\family default
\size default
et 
\family typewriter
\size small
Courbe
\family default
\size default
, 
\family typewriter
\size small
Magnétique
\family default
\size default
 et 
\family typewriter
\size small
Electrique
\family default
\size default
.
 La classe 
\family typewriter
\size small
Magnétique
\family default
\size default
 hérite à la fois de 
\family typewriter
\size small
Droit
\family default
\size default
 et de 
\family typewriter
\size small
Courbe
\family default
\size default
, tandis que 
\family typewriter
\size small
Electrique
\family default
\size default
 n'hérite 
\begin_inset Quotes eld
\end_inset

que
\begin_inset Quotes erd
\end_inset

 de 
\family typewriter
\size small
Droit
\family default
\size default
.
\end_layout

\begin_layout Section*
Question P6.2
\end_layout

\begin_layout Standard
Les champs magnétiques et électriques sont représentés à l'aide :
\end_layout

\begin_layout Standard
- d'un 
\family typewriter
\size small
Vector3D
\family default
\size default
 indiquant la direction du champ, pour l'instant ne dépendant pas de la
 position de la particule dans l'
\family typewriter
\size small
Element
\family default
\size default
,
\end_layout

\begin_layout Standard
- d'un 
\family typewriter
\size small
double
\family default
\size default
 indiquant la valeur constante de l'intensité de chaque champ.
\end_layout

\begin_layout Standard
En effet, en physique on représente les lignes de champ par des lignes parrallèl
es, continues, et nous disons que le champ a une certaine intensité, qui
 reste la même tout le long des lignes.
 Or en informatique, cela ne nous intéresse pas de représenter ces lignes.
 Puisque les seules interactions de ces champs avec les particules invoquent
 des vecteurs représentant l'intensité et la direction du champ à l'endroit
 où se trouve la particule par rapport à l'
\family typewriter
\size small
Element
\family default
\size default
, on n'a besoin que d'un 
\family typewriter
\size small
Vector3D
\family default
\size default
, et d'un 
\family typewriter
\size small
double
\family default
\size default
 fournissant son intensité.
 Nous avons cependant choisi d'opérer un distinction entre norme et direction,
 en vue d'une éventuelle amélioration du code, où nous n'aurions besoin
 de l'intensité qu'une seule fois pour toutes, et nous aurions le loisir
 de modifier la direction comme bon nous semble.
\end_layout

\begin_layout Section*
Question P6.3
\end_layout

\begin_layout Standard
Dans la classe 
\family typewriter
\size small
Courbe
\family default
\size default
, nous avons implémenté le centre de courbure sous forme d'un 
\family typewriter
\size small
Vector3D
\family default
\size default
, puisque tous les points sont naturellement représentés par des vecteurs
 dans 
\begin_inset Formula $\mathbb{R^{3}}$
\end_inset

.
\end_layout

\begin_layout Section*
Question P6.4
\end_layout

\begin_layout Standard
Afin qu'une particule soit dans un et un seul à la fois, nous avons décidé
 de rajouter un pointeur à chaque particule, qui soit responsable de lui
 indiquer dans quel 
\family typewriter
\size small
Element
\family default
\size default
 elle doit être.
 Cela pour garantir un effet de traçababilité.
\end_layout

\end_body
\end_document
