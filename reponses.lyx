#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{color}
\end_preamble
\use_default_options true
\language french
\inputencoding auto
\font_roman charter
\font_sans default
\font_typewriter cmtt
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Réponses aux questions
\end_layout

\begin_layout Author
J.
 Odersky 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 C.
 Vázquez
\end_layout

\begin_layout Section*
Question P1.1
\end_layout

\begin_layout Standard
Un vecteur est représenté par la classe `Vector3D'.
 Cette classe comprend trois champs privés du type double: x, y et z corresponda
nt aux composantes du vecteur.
 Ces champs peuvent être accédés respectivement par les méthodes publiques
 getX(), getY() et getZ().
 Les méthodes 
\begin_inset Quotes eld
\end_inset

opérateurs
\begin_inset Quotes erd
\end_inset

 sur les vecteurs (par exemple l'addition, la norme, etc...) sont toutes publiques.
\end_layout

\begin_layout Standard
Ces méthodes s'appuient entre-elles, par exemple la méthode `opposée' retourne
 le vecteur multiplié par moins un et la méthode `soustraction' additionne
 l'opposé.
 C'est à partir de cette idee que nous avons aussi implémenté une norme
 au carré (=produit scalaire du vecteur avec lui-même) et une norm (=racine
 de la norme au carré).
 Ces appels consécutifs diminuent la performance d'une façon minimale mais
 évitent un duplicage de code considérable.
\end_layout

\begin_layout Standard
Un vecteur est complètement invariable.
 C'est-à-dire qu'une fois un vecteur initialisé, on ne peut plus changer
 ses composantes (pas de méthodes `set').
 De même, tous les opérations internes du sens mathématique (qui renvoyent
 un vecteur), renvoyent une nouvelle instance d'un vecteur.
 En aucun cas l'instance d'un vecteur n'est modifiée! Ceci facilite énormément
 le raisonement sur toute variable de type vecteur, c'est-à-dire qu'on peut
 toujours être sûr que personne n'a modifié le vecteur sur lequel on travaille.
 De plus, l'invariance d'un vecteur paraît naturelle, comme celle d'un nombre
 réel.
\end_layout

\begin_layout Standard
Quelques vecteurs remarquables sont définis comme variables statiques constantes.
 Parmi ceux-ci notamment le vecteur nulle (Null) et les vecteurs unitaires
 i, j, k selon respectivement les axes x, y et z.
\end_layout

\begin_layout Standard
Pour contourner la perte de performance due à l'immutabilité des vecteurs,
 nous avons rajouté un classe `MutableVector3D'.
 Cette classe représente des vecteurs mutables lesquelles peuvent changer
 leurs coordonnées.
 Ces vecteurs sont presque exclusivement utilisés pour représenter des champs
 qui varient souvent tel que la position d'une particule.
\end_layout

\begin_layout Section*
Question P3.1
\end_layout

\begin_layout Standard
Nous n'avons pas rajouté un constructeur de copie.
 Comme la classe `Vector3D' est invariable et ne contient pas de pointeurs
 ou références sur d'autres objets mutables, elle n'a pas d'état et donc
 l'utilisation du constructeur de copie par défaut suffit.
\end_layout

\begin_layout Standard
En revanche la classe `MutableVector3D' contient un constructeur de copie
 qui copie les champs d'un vecteur donné.
\end_layout

\begin_layout Section*
Question P3.2
\end_layout

\begin_layout Standard
Lorsque l'on décide d'implémenter le constructeur par défaut (qui crée un
 vecteur nul) et le constructeur par coordonnés cartésiennes dans une seule
 et même méthode, il se peut que lorsque l'on crée une nouvelle instance
 de Vector3D sans l'initialiser (en laissant donc le soin au constructeur
 par défaut de le faire), on se retrouve avec un vecteur nul à un endroit
 où il vaudrait mieux ne pas en avoir.
 Par conséquent, en séparant ces deux méthodes, le programmeur est amené
 à penser dès l'instanciation à quelle fin il crée son objet.
\end_layout

\begin_layout Section*
Question P3.3
\end_layout

\begin_layout Subsection*
a
\end_layout

\begin_layout Standard
En ajoutant un constructeur par coordonnées sphériques, les attributs de
 la classe ne devraient pas forcémant être changées.
 Il serait toute à fait envisageable, de garder les coordonnées carthésiennes
 comme attributs et de convertir les coordonnées sphériques avec le constructeur.
 L'accès et la modification des coordonnées shpériques pourrait égelement
 se faire par un méthode convertissant les deux types de coordonnées.
\end_layout

\begin_layout Subsection*
b
\end_layout

\begin_layout Standard
La surcharge serait une difficulté majeur pour créer un constructeur par
 coordonnées sphériques.
 Etant donné qu'un tel constructeur prendrait comme paramètres deux angles
 et une longueur, représentés par trois doubles, il serait en conflit avec
 le constructeur de coordonnées carthésiennes.
 Il serait alors impossible d'avoir les deux constructeurs dans une classe.
\end_layout

\begin_layout Standard
Néanmoins, une solution alternative serait d'implémenter une méthode statique
 (
\begin_inset Quotes eld
\end_inset

factory method
\begin_inset Quotes erd
\end_inset

) qui prendrait comme paramètres des coordonnées sphériques et qui renverait
 un vecteur ayant des coordonnées carthésiennes équivalentes (par exemple
 
\family typewriter
Vector3D Vector3D::fromSpherical(double phi, double theta, double r)
\family default
).
\end_layout

\begin_layout Section*
Question P3.4
\end_layout

\begin_layout Standard
La méthode `affiche()' d'un vecteur a été implémenté sous forme de l'opérateur
 `<<' de `std::ostream'.
 La méthode `compare' est équivalent à l'opérateur `=='.
\end_layout

\begin_layout Section*
Question P5.1
\end_layout

\begin_layout Standard
Les membres d'une particule représentant le facteur gamma
\begin_inset Formula $\gamma$
\end_inset

 et l'énergie
\begin_inset Formula $E$
\end_inset

 peuvent être implémentés soit sous forme d'attributs soit sous forme de
 méthodes.
 Il y a des avantages et inconvénients pour chaque forme.
\end_layout

\begin_layout Standard
L'avantage d'un attribut est que son accès est très rapide et ne prend (presque)
 pas de temps de calcul.
 Par contre, si la valeur d'un attribut est relié logiquement à la valeur
 d'un autre attribut et que ce dernier est modifié, il faudra manuellement
 changer le premier.
 Par exemple, le facteur gamma étant défini par:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\gamma=\frac{1}{\sqrt{1-\left(\frac{v}{c}\right)^{2}}}\]

\end_inset


\end_layout

\begin_layout Standard
si il est défini comme variable, il faudrait le mettre à jour à chaque fois
 que la vitesse change.
\end_layout

\begin_layout Standard
Contrairement à un attribut, une méthode est évaluée à chaque fois qu'on
 l'appelle.
 Ceci a l'avantage que si le résultat d'une méthode dépend d'une variable,
 la variable pourra être modifiée sans autre considération.
 Ainsi, si le facteur gamma est une méthode, une mise à jour de la vitesse
 pourra être effectuée directement sans explicitement changer 
\begin_inset Formula $\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
Dans le cas de notre projet, nous avons décidés d'implémenter l'énergie
 sous forme de méthode et le facteur gamma sous forme d'attribut.
 Ceci pour plusieurs raisons:
\end_layout

\begin_layout Enumerate
Au cours de la simulation, le facteur gamma est accédé autant de fois que
 la vitesse, il est donc plus rapide de n'evoluer une racine qu'une seule
 fois pour un pas de temps.
\end_layout

\begin_layout Enumerate
L'énergie est accédée beaucoup plus rarement que la vitesse mais dépend
 quand même de cette dernière, ainsi nous avons décidé de l'implémenter
 sous forme de méthode.
\end_layout

\begin_layout Section*
Question P6.1
\end_layout

\begin_layout Standard
Pour représenter et organiser les éléments, nous avons créé une classe abtsraite
 `Element'.
 Celle-ci contient tous les attributs généraux d'un élément.
 De plus, elle contient des méthodes virtuelles pures tels que la détermination
 si une particule a heurté le bord ou est passé au suivant.
\end_layout

\begin_layout Standard
Dans la hierarchie en dessous de `Element' se trouvent deux classes representant
s les élements droits et courbes.
 Ceux-ci implémentent tout méthode relatif à la géométrie d'un élément (p.ex.
 les méthodes mentionés ci-dessus).
\end_layout

\begin_layout Standard
Finalement, en dessous de ces classes se trouvent les implémentations concrètes
 telles que les quadripoles, dipoles, etc...
\end_layout

\begin_layout Standard
Nous n'avons pas faits de classes séparés pour des élements générants un
 champ électrique ou magnétique car nous considérons qu'un élément ne générant
 pas de champ 
\emph on
possède
\emph default
 un champ nul.
 (voir question P6.2)
\end_layout

\begin_layout Section*
Question P6.2
\end_layout

\begin_layout Standard
Les champs magnétiques et électriques sont représentés par les méthodes
 `magneticFieldAt' et `electricFieldAt'.
 Ces méthodes prennent comme paramètre une position et renvoyent un vecteur
 représentant le champ à cette position.
\end_layout

\begin_layout Standard
Ceci représente concrètement les lignes de champs à un endroit donné.
\end_layout

\begin_layout Standard
En effet, en physique on représente les lignes de champ par des lignes continues.
 Or dans ce projet, cela ne nous intéresse pas de représenter ces lignes.
 Puisque les seules interactions de ces champs avec les particules invoquent
 des vecteurs représentant l'intensité et la direction du champ à l'endroit
 où se trouve la particule par rapport à l'
\family typewriter
\size small
Element
\family default
\size default
, on n'a besoin que d'un 
\family typewriter
\size small
Vector3D
\family default
\size default
.
\end_layout

\begin_layout Section*
Question P6.3
\end_layout

\begin_layout Standard
Nous représentons le centre de courbure 
\family typewriter
\size small
curvatureCenter
\family default
\size default
 à l'aide d'un attribut du type 
\family typewriter
\size small
Vector3D
\family default
\size default
 que l'on instancie indirectement en fournissant la courbure 
\family typewriter
\size small
k
\family default
\size default
 au constructeur des éléments courbes.
\end_layout

\begin_layout Standard
En effet, le centre de courbure d'une courbe est défini d'une manière unique
 si nous avons :
\end_layout

\begin_layout Itemize
une position d'entrée 
\family typewriter
\size small
entry
\family default
\size default
;
\end_layout

\begin_layout Itemize
une position de sortie 
\family typewriter
\size small
exit
\family default
\size default
;
\end_layout

\begin_layout Itemize
une courbure
\family typewriter
\size small
 k
\family default
\size default
 (donc un rayon de courbure 
\family typewriter
\size small
curvatureRadius
\family default
\size default
 ) avec son signe !;
\end_layout

\begin_layout Itemize
une convention à l'aide de laquelle nous savons, en fonction du signe du
 rayon, de quel côté de l'Element la courbe se courbe.
\begin_inset Foot
status open

\begin_layout Plain Layout
Les éléments courbes auront de plus une courbure k, constante (l’inverse
 du rayon de courbure), dont le signe indique le sens de courbure par rapport
 à l’orientation donnée par l’opposé de l’axe vertical (noté -
\begin_inset Formula $\overrightarrow{\textrm{e}{}^{3}}$
\end_inset

) .
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Question P6.4
\end_layout

\begin_layout Standard
Afin qu'une particule soit dans un et un seul 
\family typewriter
\size small
Element
\family default
\size default
 à la fois, nous avons décidé de rajouter un attribut privé (un pointeur)
 à chaque particule, qui soit responsable de lui indiquer dans quel 
\family typewriter
\size small
Element
\family default
\size default
 elle se trouve.
 Elle ne peut se retrouver dans deux 
\family typewriter
\size small
Element
\family default
\size default
s.
 C'est un moyen simple de coller une étiquette 'Où je suis ?' sur une particule,
 et on pourra facilement vérifier qu'à chaque évolution du système, notre
 particule ne soit que dans un et un seul 
\family typewriter
\size small
Element
\family default
\size default
 à la fois.
 Cela modifie la classe 
\family typewriter
\size small
Particule
\family default
\size default
.
\end_layout

\begin_layout Section*
Question P7.1
\end_layout

\begin_layout Standard
La classe 
\family typewriter
\size small
Accelerator
\family sans
 
\family default
\size default
un accélerateur.
 Elle contient une collection de particules et d'élements (en attributs).
 De plus, nous avons décidé qu'un accélérateur sera entièrement responsable
 de la gestion de ses particules et elements.
 Cela implique que lors de l'ajout d'un de ces derniers, il sera copié.
\end_layout

\begin_layout Standard
Cette copie entraîne d'eutres conséquences tel que le rajout d'un méthode
 `clone' dans les éléments et particules.
\end_layout

\begin_layout Section*
Question P7.2
\end_layout

\begin_layout Standard
Le constructeur de copie privé : il doit servir à empêcher tout appel au
 constructeur de copie par défaut, puisqu'il ne fait rien, on ne pourra
 simplement pas faire de copie d'
\family typewriter
\size small
Accelerator
\family default
\size default
, donc pas de passage par valeur.
\end_layout

\begin_layout Standard
L'opérateur '=' : de même que pour le constructeur de copie, sa déclaration
 en privé empêche la copie d'un accélérateur vers un autre.
\end_layout

\begin_layout Standard
Ces restrictions sont présents pour éviter des problèmes de responsabilités
 d'allocation et de délocation de mémoire (car un accélérateur contient
 beaucoup de pointeurs d'éléments et de particules qui eux-mêmes pointent
 vers des particules).
 Mais aussi d'un point de vue logique: comment serait-ce physiquement possible
 de copier un accélérateur dans un état donné avec tous ses particules?
\end_layout

\begin_layout Section*
Question P8.1
\end_layout

\begin_layout Standard
En termes de POO, cela signifie que la méthode 
\family typewriter
\size small
heurte_bord
\family default
\size default
 (`isBeside' dans notre cas) est virtuelle (même virtuelle pure à l'intérieur
 de la classe 
\family typewriter
\size small
Element
\family default
\size default
).
\end_layout

\begin_layout Section*
Question P8.2
\end_layout

\begin_layout Standard
Cela implique donc que la classe 
\family typewriter
\size small
Element
\family default
\size default
 est 
\emph on
abstraite
\emph default
.
\end_layout

\begin_layout Section*
Question P8.3
\end_layout

\begin_layout Standard
La méthode `dessine' est elle aussi virtuelle pure dans la classe dessinable.
\end_layout

\begin_layout Section*
Question P9.1
\end_layout

\begin_layout Standard
FODO
\end_layout

\begin_layout Section*
Question P10.1
\end_layout

\begin_layout Standard
Concernant les classes contenant des pointeurs, il s'agit de fixer une manière
 de gérer les pointeurs, les montrer ou non.
 Si on choisi de les montrer, alors il faut gérer les 
\family typewriter
\size small
delete
\family default
\size default
 en externe, et cela induit un plus grand risque d'erreurs, plus que si
 on choisi la deuxième option.
 Dans ce cas, on peut envisager d'écrire les 
\family typewriter
\size small
new
\family default
\size default
 et les 
\family typewriter
\size small
delete
\family default
\size default
 en interne, ce qui implique qu'on est tout seul à manipuler des pointeurs,
 ce qui est plus élégant.
\end_layout

\begin_layout Section*
Question P10.2
\end_layout

\begin_layout Standard
Dans le cadre de la programmation oritentée-objets, il s'agit, pour ne faire
 qu'une seule fois appel à la méthode
\family typewriter
\size small
 Printable
\family default
\size default
, de la redéfinir.
\end_layout

\begin_layout Section*
Question P10.3
\end_layout

\begin_layout Section*
Question P10.4
\end_layout

\end_body
\end_document
