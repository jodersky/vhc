#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{color}
\end_preamble
\use_default_options true
\language french
\inputencoding auto
\font_roman charter
\font_sans default
\font_typewriter cmtt
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Réponses aux questions
\end_layout

\begin_layout Author
J.
 Odersky 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 C.
 Vázquez
\end_layout

\begin_layout Section*
Question P1.1
\end_layout

\begin_layout Standard
Un vecteur est représenté par la classe `Vector3D'.
 Cette classe comprend trois champs privés du type double: x, y et z corresponda
nt aux composantes du vecteur.
 Ces champs peuvent être accédés respectivement par les méthodes publiques
 getX(), getY() et getZ().
 Les méthodes 
\begin_inset Quotes eld
\end_inset

opérateurs
\begin_inset Quotes erd
\end_inset

 sur les vecteurs (par exemple l'addition, la norme, etc...) sont toutes publiques.
\end_layout

\begin_layout Standard
Ces méthodes s'appuient entre-elles, par exemple la méthode `opposée' retourne
 le vecteur multiplié par moins un et la méthode `soustraction' additionne
 l'opposé.
 Ces appels consécutifs diminuent la performance d'une façon minimale mais
 évitent un duplicage de code considérable.
\end_layout

\begin_layout Standard
Un vecteur est complètement invariable.
 C'est-à-dire qu'une fois un vecteur initialisé, on ne peut plus changer
 ses composantes (pas de méthodes `set').
 De même, tous les opérations internes du sens mathématique (qui renvoyent
 un vecteur), renvoyent une nouvelle instance d'un vecteur.
 En aucun cas l'instance d'un vecteur n'est modifiée! Ceci facilite énormément
 le raisonement sur toute variable de type vecteur.
 De plus, l'invariance d'un vecteur paraît naturelle, comme celle d'un nombre
 réel.
\end_layout

\begin_layout Standard
Quelques vecteurs remarquables sont définis comme variables statiques constantes.
 Parmi ceux-ci notamment le vecteur nulle (Null) et les vecteurs unitaires
 i, j, k selon respectivement les axes x, y et z.
\end_layout

\begin_layout Section*
Question P3.1
\end_layout

\begin_layout Standard
Nous n'avons pas rajouté un constructeur de copie.
 Comme la classe `Vector3D' est invariable et ne contient pas de pointeurs
 ou références sur d'autres objets mutables, elle n'a pas d'état et donc
 l'utilisation du constructeur de copie par défaut suffit.
\end_layout

\begin_layout Section*
Question P3.2
\end_layout

\begin_layout Standard
Lorsque l'on décide d'implémenter le constructeur par défaut (qui crée un
 vecteur nul) et le constructeur par coordonnés cartésiennes dans une seule
 et même méthode, il se peut que lorsque l'on crée une nouvelle instance
 de Vector3D sans l'initialiser (en laissant donc le soin au constructeur
 par défaut de le faire), on se retrouve avec un vecteur nul à un endroit
 où il vaudrait mieux ne pas en avoir.
 Par conséquent, en séparant ces deux méthodes, le programmeur est amené
 à penser dès l'instanciation à quelle fin il crée son objet.
\end_layout

\begin_layout Section*
Question P3.3
\end_layout

\begin_layout Subsection*
a
\end_layout

\begin_layout Standard
En ajoutant un constructeur par coordonnées sphériques, les attributs de
 la classe ne devraient pas forcémant être changées.
 Il serait toute à fait envisageable, de garder les coordonnées carthésiennes
 comme attributs et de convertir les coordonnées sphériques avec le constructeur.
\end_layout

\begin_layout Subsection*
b
\end_layout

\begin_layout Standard
La surcharge serait une difficulté majeur pour créer un constructeur par
 coordonnées sphériques.
 Etant donné qu'un tel constructeur prendrait comme paramètres deux angles
 et une longueur, représentés par trois doubles, il serait en conflit avec
 le constructeur de coordonnées carthésiennes.
 Il serait alors impossible d'avoir les deux constructeurs dans une classe.
\end_layout

\begin_layout Standard
Néanmoins, une solution alternative serait d'implémenter une méthode statique
 (
\begin_inset Quotes eld
\end_inset

factory method
\begin_inset Quotes erd
\end_inset

) qui prendrait comme paramètres des coordonnées sphériques et qui renverait
 un vecteur ayant des coordonnées carthésiennes équivalentes (par exemple
 
\family typewriter
Vector3D Vector3D::fromSpherical(double phi, double theta, double r)
\family default
).
\end_layout

\begin_layout Section*
Question P3.4
\end_layout

\begin_layout Standard
La méthode `affiche()' d'un vecteur a été implémenté sous forme de l'opérateur
 `<<' de `std::ostream'.
 La méthode `compare' est équivalent à l'opérateur `=='.
\end_layout

\begin_layout Section*
Question P5.1
\end_layout

\begin_layout Standard

\emph on
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
color{red}{Réponse incohérente! La question conçernant l'énergie me perturbe...}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Les membres d'une particule représentant le facteur gamma
\begin_inset Formula $\gamma$
\end_inset

 et l'énergie
\begin_inset Formula $E$
\end_inset

 peuvent être implémentés soit sous forme d'attributs soit sous forme de
 méthodes.
 Il y a des avantages et inconvénients pour chaque forme.
\end_layout

\begin_layout Standard
L'avantage d'un attribut est que son accès est très rapide et ne prend (presque)
 pas de temps de calcul.
 Par contre, si la valeur d'un attribut est relié logiquement à la valeur
 d'un autre attribut et que ce dernier est modifié, il faudra manuellement
 changer le premier.
 Par exemple, le facteur gamma étant défini par:
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\gamma=\frac{1}{\sqrt{1-\left(\frac{v}{c}\right)^{2}}}\]

\end_inset


\end_layout

\begin_layout Standard
si il est défini comme variable, il faudrait le mettre à jour à chaque fois
 que la vitesse change.
\end_layout

\begin_layout Standard
Contrairement à un attribut, une méthode est évaluée à chaque fois qu'on
 l'appelle.
 Ceci a l'avantage que si le résultat d'une méthode dépend d'une variable,
 la variable pourra être modifiée sans considération de la méthode.
 Ainsi, si le facteur gamma est une méthode, une mise à jour de la vitesse
 pourra être effectuée directement sans explicitement changer 
\begin_inset Formula $\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
Dans le cas de notre projet, nous avons décidés d'implémenter l'énergie
 sous forme d'attribut et le facteur gamma sous forme de méthode.
 Ceci pour plusieurs raisons:
\end_layout

\begin_layout Enumerate
Au cours de la simulation, la vitesse sera changée très fréquemment, beaucoup
 plus que les appels à gamma.
 Une implémentation de gamma sous forme de méthode améliore donc la performance.
\end_layout

\begin_layout Enumerate
Le premier argument pourrait s'appliquer également à l'énergie, or il faut
 remarquer que l'énergie est une grandeur spécifiée durant la création d'une
 particule et que en fait la vitesse dépend de l'énergie
\begin_inset Foot
status open

\begin_layout Plain Layout
Complément mathématique: 
\begin_inset Quotes eld
\end_inset

Aux énergies atteintes dans un accélérateur, les particules sont tellement
 proches de la vitesse de la lumière qu'il faudrait garder au moins 7 décimales
 pour que la vitesse permette de connaître l'énergie de façon assez précise.
 On caractérise donc plutôt une particule en termes d'énergie totale que
 de vitesse.
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 On pourrait alors penser à définir la vitesse comme méthode mais d'après
 l'argument 1, ce serait complètement absurde au niveau de la performance.
\end_layout

\begin_layout Section*
Question P6.1
\end_layout

\begin_layout Standard
Pour représenter et organiser les 
\family typewriter
\size small
Element
\family default
\size default
s, nous avons choisi dans ce projet de coder les 
\family typewriter
\size small
Element
\family default
\size default
s 
\family typewriter
\size small
[Magnetic (StraightElement
\family default
\size default
 et 
\family typewriter
\size small
CurvedElement)
\family default
\size default
 et 
\family typewriter
\size small
Electric
\family default
\size default
] sous formes de classes.
 Concrètement, la classe 
\family typewriter
\size small
Element
\family default
\size default
 est la classe grand-mère, les trois classes filles sont les classes
\family typewriter
\size small
 StraightElement
\family default
\size default
, 
\family typewriter
\size small
CurvedElement
\family default
\size default
 et 
\family typewriter
\size small
Magnetic
\family default
\size default
.
 Les trois classes petites-filles sont 
\family typewriter
\size small
MagneticStraightElement
\family default
\size default
, 
\family typewriter
\size small
MagneticCurvedElement
\family default
\size default
 et 
\family typewriter
\size small
Electric
\family default
\size default
, où 
\family typewriter
\size small
MagneticStraightElement
\family default
\size default
 hérite à la fois de 
\family typewriter
\size small
Magnetic
\family default
\size default
 et de 
\family typewriter
\size small
StraightElement
\family default
\size default
, et où 
\family typewriter
\size small
MagneticCurvedElement
\family default
\size default
 hérite de 
\family typewriter
\size small
Magnetic
\family default
\size default
 et de 
\family typewriter
\size small
CurvedElement
\family default
\size default
.
 
\family typewriter
\size small
Electric
\family default
\size default
 n'hérite 'que' de 
\family typewriter
\size small
StraightElement
\family default
\size default
.
\end_layout

\begin_layout Section*
Question P6.2
\end_layout

\begin_layout Standard
Les champs magnétiques et électriques sont représentés à l'aide d'un 
\family typewriter
\size small
Vector3D
\family default
\size default
 indiquant la direction et l'intensité du champ, et nous allons nous arranger
 pour que sa norme soit initialisée une fois pour toutes (pour garder l'intensit
é de champ constante).
 Ainsi, à chaque nouvelle manipulation (modification d'orientation) du 
\family typewriter
\size small
Vector3D
\family default
\size default
 
\family typewriter
\size small
field
\family default
\size default
, nous ferons appel à la méthode 
\family typewriter
\size small
rotate
\family default
\size default
.
 Ce faisant, puisque la rotation est une isométrie, nous pouvons définir
 n'importe quelle orientation que pourrait prendre le champ, en nous assurant
 d'avoir une intensité de champ constante.
\end_layout

\begin_layout Standard
En effet, en physique on représente les lignes de champ par des lignes parrallèl
es, continues, et nous disons que le champ a une certaine intensité, qui
 reste la même tout le long des lignes.
 Or dans ce projet, cela ne nous intéresse pas de représenter ces lignes.
 Puisque les seules interactions de ces champs avec les particules invoquent
 des vecteurs représentant l'intensité et la direction du champ à l'endroit
 où se trouve la particule par rapport à l'
\family typewriter
\size small
Element
\family default
\size default
, on n'a besoin que d'un 
\family typewriter
\size small
Vector3D
\family default
\size default
.
\end_layout

\begin_layout Section*
Question P6.3
\end_layout

\begin_layout Standard
Nous représentons le centre de courbure 
\family typewriter
\size small
centerOfCurvature
\family default
\size default
 à l'aide d'un 
\family typewriter
\size small
Vector3D
\family default
\size default
 que l'on instancie indirectement en fournissant la courbure 
\family typewriter
\size small
k
\family default
\size default
 à une fonction statique, qui nous renvoie 
\series bold
la
\series default
 position du centre de courbure (cf.
 constructeur de 
\family typewriter
\size small
curved
\family default
\size default
 dans 
\family typewriter
\size small
CurvedElement.cc
\family default
\size default
).
\end_layout

\begin_layout Standard
En effet, le centre de courbure d'une courbe est défini d'une manière unique
 si nous avons :
\end_layout

\begin_layout Standard
- une position d'entrée 
\family typewriter
\size small
entry
\family default
\size default
;
\end_layout

\begin_layout Standard
- une position de sortie 
\family typewriter
\size small
exit
\family default
\size default
;
\end_layout

\begin_layout Standard
- une courbure
\family typewriter
\size small
 k
\family default
\size default
 (donc un rayon de courbure 
\family typewriter
\size small
curvatureRadius
\family default
\size default
 ) avec son signe !;
\end_layout

\begin_layout Standard
- une convention à l'aide de laquelle nous savons, en fonction du signe
 du rayon, de quel côté de l'Element la courbe se courbe.
\begin_inset Foot
status open

\begin_layout Plain Layout
Les éléments courbes auront de plus une courbure k, constante (l’inverse
 du rayon de courbure), dont le signe indique le sens de courbure par rapport
 à l’orientation donnée par l’opposé de l’axe vertical (noté -
\begin_inset Formula $\overrightarrow{\textrm{e}{}^{3}}$
\end_inset

) .
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Question P6.4
\end_layout

\begin_layout Standard
Afin qu'une particule soit dans un et un seul 
\family typewriter
\size small
Element
\family default
\size default
 à la fois, nous avons décidé de rajouter un attribut privé (un pointeur)
 à chaque particule, qui soit responsable de lui indiquer dans quel 
\family typewriter
\size small
Element
\family default
\size default
 elle se trouve.
 Elle ne peut se retrouver dans deux 
\family typewriter
\size small
Element
\family default
\size default
s.
 C'est un moyen simple de coller une étiquette 'Où je suis ?' sur une particule,
 et on pourra facilement vérifier qu'à chaque évolution du système, notre
 particule ne soit que dans un et un seul 
\family typewriter
\size small
Element
\family default
\size default
 à la fois.
 Cela modifie la classe 
\family typewriter
\size small
Particule
\family default
\size default
.
\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
